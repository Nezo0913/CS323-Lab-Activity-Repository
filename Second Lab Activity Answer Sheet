QUESTIONS:

1. Which approach demonstrates true parallelism in Python? Explain.

In the multithreading code, Python uses something called the GIL, which only lets one thread run at a time, even if the computer is multi-cored. So the threads just take turns running, which means it’s not real parallel work, just shared time.
In the multiprocessing code, each task runs in a separate process, and each process can use a different CPU core. Because of that, the tasks really run at the same time, showing true parallelism.


2. Compare execution times between multithreading and multiprocessing.

 Multithreading executes faster than multiprocessing for I/O-bound tasks due to lower overhead. For example, the execution time of multithreading is 47s (3 courses) with time.sleep(), but it outperforms multiprocessing if executed without it. Multiprocessing, on the other hand, significantly outperforms multithreading for CPU-bound tasks by enabling true parallel execution across multiple CPU cores.

3. Can Python handle true parallelism using threads? Why or why not?

No, Standard python (CPyhon) cannot achieve true parallelism with threads for CPU bound work, However threading is effective for I/O-bound operations, where threads can run concurrently while waiting for external events. 

In our code, concurrency is achieved because time.sleep() releases GIL, but threads are not executing CPU instructions in parallel, True parallelism in Python requires multiprocessing.


4. What happens if you input a large number of grades (e.g., 1000)? Which method is faster and why?

If 1000 grade were input, multiprocessing would be the faster method
It’s because multiprocessing distributes the workload across all available CPU cores, whereas multithreading would create a massive overhead of threads that are still restricted by the GIL to running one at a time.

5. Which method is better for CPU-bound tasks and which for I/O-bound tasks?

Multiprocessing is the superior method for CPU-bound tasks, such as complex mathematical calculations, because it enables true parallel execution across multiple cores. Conversely, multithreading is often better suited for I/O-bound tasks, such as network requests or file reading, where the program spends most of its time waiting and can switch between threads to remain efficient

6. How did your group apply creative coding or algorithmic solutions in this lab?

Our group applied creative coding by using multithreading to process multiple subject grades concurrently instead of sequentially. Algorithmic techniques such as thread creation, synchronization using locks, and data aggregation were used to ensure efficiency and correctness. This approach simulated real-world concurrent systems while maintaining safe access to shared resources
