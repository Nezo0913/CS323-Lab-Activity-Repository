Implementation 
Sequential Version:

import time
NUM_GARMENTS = 20
def measure():
    time.sleep(0.01)
def cut():
    time.sleep(0.01)
def sew():
    time.sleep(0.05)  # bottleneck (longest stage)
def assemble():
    time.sleep(0.01)
def sequential():
    start = time.time()
    for _ in range(NUM_GARMENTS):
        measure()
        cut()
        sew()
        assemble()
    end = time.time()
    return end - start


Parallel Version:

import time
from concurrent.futures import ThreadPoolExecutor
from threading import Semaphore, Lock
NUM_GARMENTS = 20
MAX_MACHINES = 4 # number of sewing machines
machine_semaphore = Semaphore(MAX_MACHINES)
storage_lock = Lock()
completed = 0

def measure_and_cut():
time.sleep(0.01)
time.sleep(0.01)

def sew_parallel(_):
global completed

with machine_semaphore: # MachineLock
time.sleep(0.05) # sewing bottleneck

time.sleep(0.01) # assembly

with storage_lock: # StorageSync
completed += 1

def parallel():
start = time.time()

# Sequential preprocessing
for _ in range(NUM_GARMENTS):
measure_and_cut()

# Parallel sewing stage
with ThreadPoolExecutor(max_workers=MAX_MACHINES) as executor:
executor.map(sew_parallel, range(NUM_GARMENTS))

end = time.time()
return end - start




Benchmarking :
if __name__ == "__main__":

print("Running Sequential Version...")
seq_time = sequential_process()
print(f"Sequential Execution Time: {seq_time:.4f} seconds\n")

print("Running Parallel Version...")
par_time = parallel_process()
print(f"Parallel Execution Time: {par_time:.4f} seconds\n")

speedup = seq_time / par_time

print("---------- BENCHMARK RESULT ----------")
print(f"Total Garments: {NUM_GARMENTS}")
print(f"Sewing Machines (Workers): {MAX_MACHINES}")
print(f"Sequential Time: {seq_time:.4f} seconds")
print(f"Parallel Time: {par_time:.4f} seconds")
print(f"Speedup: {speedup:.2f}x")


import time

# -------------------------------
# Stage Functions
# -------------------------------

def measuring(item_id: int):
    print(f"Item {item_id}: Measuring...")
    time.sleep(2.0)

def pattern_cutting(item_id: int):
    print(f"Item {item_id}: Pattern & Cutting...")
    time.sleep(3.0)

# Bottleneck stage
def sewing(item_id: int):
    print(f"Item {item_id}: Sewing started...")
    time.sleep(5.0)  
    print(f"Item {item_id}: Sewing finished.")

def finishing(item_id: int):
    print(f"Item {item_id}: Finishing...")
    time.sleep(2.0)

def storage(item_id: int):
    print(f"Item {item_id}: Placed in storage.")
    time.sleep(1.0)

# -------------------------------
# Sequential Workflow
# -------------------------------

def sequential_workflow(num_items: int):
    start = time.time()
    results = []

    # Start item numbering at 1
    for i in range(1, num_items + 1):
        print(f"\n--- Processing Item {i} ---")
        measuring(i)
        pattern_cutting(i)
        sewing(i)          # Critical bottleneck
        finishing(i)
        storage(i)
        results.append(f"Item {i} completed")

    end = time.time()
    total_time = end - start
    return results, total_time


# -------------------------------
# Run Sequential Workflow
# -------------------------------
if __name__ == "__main__":
    num_items = 3  # Number of items to process in the workflow (can be adjusted)
    print("\n=== Sequential Workflow Execution ===")
    results, seq_time = sequential_workflow(num_items)

    print("\nResults:")
    for r in results:
        print(r)

    print(f"\nTotal Sequential Time: {seq_time:.2f} seconds")



